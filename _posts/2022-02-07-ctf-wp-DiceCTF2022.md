---
layout: post
title: DiceCTF2022 wp
author: Rechn0
date: 2022-02-07 14:30 +0800
last_modified_at: 2022-02-07 14:30 +0800
tags: [wp, crypto]
categories: [ctf, wp]
toc:  true
math: true
---

DiceCTF2022

假期摸鱼，记录解题思路与复现情况

## **Crypto**

[DiceCTF wp by y011d4](https://blog.y011d4.com/20220207-dicectf-writeup/#crypto)

### babyrsa

Problem: 给出e,c,n其中e与 \\\( \phi(n) \\\) 不互素

**思路：**

n规模较小，暴力分解后检验发现 \\\( gcd(e, \phi(n) )=e \\\)

经典AMM开根crt合并，筛选解空间得到flag

对不起，我选择f.roots()

```python
from babyrsa import e,cipher,p,q
# factor N before solving
def nth_solve(n,c,p):
    R.<x>=PolynomialRing(GF(p))
    f=x^n-c
    f=f.monic()
    return f.roots()

m1=nth_solve(e,cipher,p)
m2=nth_solve(e,cipher,q)
for i in m1:
    for j in m2:
        m=crt([i[0],j[0]],[p,q])
        m=long_to_bytes(m)
        if b'dice{' in m:exit(print(m))
```

dice{cado-and-sage-say-hello}

### commitment-issues

Problem: 魔法签名，给定e，N，同时给出 \\\( c1=s+key,c2=key^5 \pmod{N} \\\) 用于签名认证

赛时思路：

5次幂好小，可以开根(？)

(甚至虚心请问了队里的密码学师傅，对不起)

**思路：**

主要思想是基于m相对较小这一特征，构造方程使用coppersmith攻击求解小根。攻击分为两步

第一步需要求出 \\\( f=(c_1-k)^e \pmod{N} \\\) ，易知m即为该式的根。由于该多项式次数较高，考虑使用 \\\( k^5=c_2 \pmod{N} \\\) 进行约简，最终可以得到关于变量key的4次多项式结果

```python
# Step 1

## Solution 1

PRk.<k>=PolynomialRing(Zmod(N))
def reduct(f):
    g=f%(k^5)
    h=(f-g)//(k^5)
    return c2*h+g
def qpow(f,e):
    res=1
    while e:
        if e%2:
            res=reduct(res*f)
        f=reduct(f*f)
        e>>=1
    return res
f=qpow(PRk(c1-k),e)

## Solution 2

PRk.<k>=PolynomialRing(Zmod(N))
I=PRk.ideal(k^5-c2)
PRI=PRk.quotient_ring(I)
f=PRI(c1-k)**e
f=PRk(str(f).replace('kbar','k'))
```

此处的约简操作与理想、商环的理论知识有关，因此可以使用第二种方案借助sage实现多项式商环求解。注意这种方法下sage会对多项式变量名进行变更，需要手动更改

*理想与商环知识候补

第二步即需要求出一组(k,m)满足

$$
\left\{
    \begin{array}{l}
        f(k,m)=(c1-k)^e-m=0\\
        g(k,m)=k^5-c_2=0\\
    \end{array}
\right.
\pmod{N}
$$

消去k，即可得到关于m的5次多项式，利用small_roots()函数求解小根即可。该步骤可以使用resultant实现，也可以求解Sylvester矩阵的行列式

在sagemath中，若两多项式相对变量均为正次数，则resultant()函数即求解Sylvester矩阵行列式，故两者等价

*但是复现的时候resultant()会出现报错，不是很清楚原因

```python
# Step 2

PRkm.<k,m>=PolynomialRing(Zmod(N))
f=PRkm(f-m)
g=PRkm(k^5-c2)

## Solution 1
res=f.sylvester_matrix(g,k).det()

## Solution 2
res=f.resultant(g,k)
```

*Sylvester Matrix可以根据两个多项式系数进行构造，若两多项式存在非常数的公因式，则矩阵的行列式为零

*small_roots()函数的epsilon参数会影响到最小根求解的范围，可能会导致无解or求解时间较长

完整solver如下

```python
# sage
from commitment-issues import N,c1,c2,e
def reduct(f):
    g=f%(k^5)
    h=(f-g)//(k^5)
    return c2*h+g
def qpow(f,e):
    res=1
    while e:
        if e%2:
            res=reduct(res*f)
        f=reduct(f*f)
        e>>=1
    return res

PRk.<k>=PolynomialRing(Zmod(N))
I=PRk.ideal(k^5-c2)
PRI=PRk.quotient_ring(I)
f=PRI(c1-k)**e
f=PRk(str(f).replace('kbar','k'))

PRkm.<k,m>=PolynomialRing(Zmod(N))
f=PRkm(f-m)
g=PRkm(k^5-c2)
res=f.sylvester_matrix(g,k).det()

PRm.<m>=PolynomialRing(Zmod(N))
res=PRm(res).monic()
ans=int(res.small_roots(epsilon=0.05)[0])
print(ans.to_bytes(31,'big'))
```

dice{wh4t!!-wh0_g4ve_u-thE-k3y}

### rejected

Problem: 随机数产生系统，可以设定模数

赛时思路：

从前基本没有分析过在线的题目，比较没有经验。

分析发现系统底层是64bitLFSR，每次会取32bit产生随机数，系统不断迭代直到产生小于截断界限的随机数。然而，我们能够得到的回显只有产生该随机数使用的轮数。

分析发现系统截断会由指定的模数产生，故构造模数N可以影响到截断的效果。赛时考虑到N=pow(2,30)+1，此时cutoff=pow(2,31)+2，可以区分最高位为0/1的状态？

一方面是想的不够深入，另一方面通过这些离散bit也不太会恢复LFSR的前继状态。随缘复现，原地留坑

**思路：**

### correlated

---